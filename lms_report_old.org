* ABSTRACT
Library Management System is a software used to manage the catalog of
a library. This helps to keep the records of all the transaction of
books available in the library. Each patron and the item has a unique
ID in the database that allows the Library Management System to track
its activity.

* LITERATURE SURVEY
We've conducted a short survey/review on the works that has been done
to improve the library management system of Medium and small
libraries. The review consists of a problem statement that has been
surfaced during our investigation of previous systems and it also
holds a proposition on how to solve the problem with a working
model. The attached file also contains a detailed model and SRS of the
solution that has been proposed for medium and small libraries.
	
The review is based on the development that has been done in the last
15 years and sees no reason to look further back than the said
timespan because of obsolescence and the rapid development of
technology.

** Introduction
Automated Library Management Systems emerged in the 1970-s. Though
started as a simple database to house and retrieve a library's
holdings, with the inception of the Internet in 1990-2000 timespan, it
has been evolved into a much bigger thing. A system that can retrieve
data remotely and can hold large clusters of book data and serve them
worldwide.
** Previous Works
Any computer based system evolves with the evolution in computer
technology itself. Library Management systems are no different.

After the introduction of Web 1.0 (i.e. the Internet), the initial
plan of action was to setup and deploy OPAC(Open Public Access
Catalog),on a web server, some time after this, rich GUI building
tools like VB or VC++ became available.
	
The web based transaction system for catalogs was first proposed and
deployed in the 1990-s after JAVA and .NET became leader in web
application development and could make use of the REST model.
	
In 2000s, the Web 2.0 was introduced and the concept of OTA updates
became popular. The web, by this time was fully capable of delivering
rich content and reliable information delivery system. The APIs became
popular and a lot of open web based REST services for getting
information on books became available, such as Amazon and
LibraryThing.
	
But the development somehow stopped after that, people failing to
develop reliable cloud based library management system which could be
a cost effective solution.

** Problems in Previous Works
Everything when in a constant development cycle has some faults. The
instance of Library Management Systems is no different. We try to
build the problem statement based on the faults.

*** Problems with the Evolution in Technology
As already discussed, the Internet evolved to a more cloud based
system for everything but Library Management Systems are not
evolving. They are still storing all the data in a single database
which is accessible only via the library and not directly by the
patrons.
	
For a small or medium library, it's not feasible to run a local server
to hold the catalog data of the books that a library holds, let alone
serving the data real time to multiple patrons.

*** Changes in User Behaviors and Demands
The most difficult problem to cope up with is the demands of the
users(patrons in this particular case). They are ever increasing and
system is far behind the time line which the evolution of Web Based
systems are following. The few most common demands by the users are
listed here -
    - Users want greater freedom in managing the access to information.
	- Users want access to the information on a book, not just if
          the library is holding a book or not.
	- More simple UI and search interfaces are demanded.

The most important of all these is that users want everything on a
mobile based platform. The current system that is in circulation, is
incompetent to handle this problem and needs a refinement, a more
flexible, economic and user friendly option.

** Proposed Solution
The solution of the above stated problems can be simplified
and divided into two parts.

*** Upgrading the Current System with Cloud Computing
The current system can be upgraded to cloud computing by simply
converting the system to a REST API based data retrieval.
	
By this, we can send data to a server using AJAX requests from a web
page or WebApp and get the data in JSON format. We can then parse the
data and show it to the user as the user want.

*** User Experience Customization
Using REST can grant high modularity on what
the server sends to the user based on the request that has been
done. For example, we can show the user a book is available or not
along with the details of the book if the user wants.

*** More Features
We can reduce a major portion of manual data entry by populating data
fields based upon the entered ISBN using the camera of a phone or (in
case it's a computer station) using an EAN-13 code scanner. This can
also be done for normal users who just want an information on a book.

* INTRODUCTION
*** Purpose
Library is considered as one of the most important things in an
educational institute. However, managing a library is no simple
task. This can be a primary reason for a communication disaster
between a student and the librarians. A more modern and streamlined
approach is the sole purpose of this project by which, the
communication failures can be avoided.

*** Scope
The scope of the project is a variable entity. Primarily, the system
is targeted for the small and medium libraries but can be scaled
easily and modified to run on any sized library.

However, there are also some considerations to be taken, the primary
one being that the project is solely focused and targeted on the
educational institutions. Taken that into consideration, the project
also can be used as a boilerplate for developing solutions for paid
and public libraries.

*** Definitions
|--------------+-----------------------------------|
| Abbriviation | Full Form                         |
|--------------+-----------------------------------|
| LMS          | Library Management System         |
| UI           | User Interface                    |
| DB           | Database                          |
| API          | Application Programming Interface |
| REST         | Representational State Transfer   |
| CRUD         | Create, Read, Update and Delete   |
| MVC          | Model, View and Controller        |
| NIC          | Network Interface Card            |
|--------------+-----------------------------------|

** Product Description
*** Product Description
The product is a Library Management System based on REST, CRUD and a
client-server standard MVC application model. Along with the Android
application, the product can also have a web based interface as in the
back-end of the application, there's an API that's controlling the
requests and responses to and from the server.

The API can also be adopted to use for developing the same application
for other platforms, namely /iOS, Windows Phone, Windows, Linux and
macOS/.

*** Product Functions
The product functions on a request and response model. The Application
(hereinafter referred to as /'the client'/) sends an HTTP request and
the server responses in according to it, sending back some data in
JSON for parsing in the client side. The client then parses the data
and generates a view for the user to see based on the data it
recieved. Primarily, there are three authentication levels. Admin,
Librarian and Student.

- Admin :: The admin is responsible for adding and removing librarians
           and also the managing the API.
- Librarian :: The librarian is responsible for adding and removing
               students and also managing books.
- Student :: The students can see the books that are in the library,
             see if the books are available or not and also the due
             date.

** Constraints
*** Constraints
There is virtually no constraint in terms of usability of the app in
different environments, from small to very large libraries. As it is
built on a semi modifiable API, different variables and queries can be
added easily and the application can be reprogrammed accordingly.

The only real constraint can be the server and database hardaware, but
with platforms like *Amazon AWS EC2, Digital Ocean, Heroku and Google
Cloud Console* in play, the cost to performance ration and constraint
in hardware should not be a problem.

*** Dependencies
- Google Mobile Vision :: The Mobile Vision API provides a framework
     for finding objects in photos and video. The framework includes
     detectors, which locate and describe visual objects in images or
     video frames, and an event driven API that tracks the position of
     those objects in video. Currently, the Mobile Vision API includes
     face, barcode, and text detectors, which can be applied
     separately or together.
- Android SDK :: Android software development is the process by which
                 new applications are created for devices running the
                 Android operating system. Applications are usually
                 developed in Java (and/or Kotlin; or other such
                 option) programming language using the Android
                 software development kit (SDK), but other development
                 environments are also available, some such as Kotlin
                 support the exact same Android APIs (and bytecode),
                 while others such as Go have restricted API
                 access. All Java 7 language features are supported,
                 and some Java 8 language features (and additionally
                 some Java 9 code has been backported to work).

*** Apportioning of Requirements
- Server Side :: Most of the work is done on the server side, so the
                 server side needs to be good according to the
                 requirement of the libary.
- Client Side :: On the other hand, the client side can have any
                 normal android phone and operate flawlessly.

* REQUIREMENTS
** Specific Requirements
*** Hardware Interfaces
1. Server Side :: Hardware requirements on the server side can be
                  considered as a variable. It can be changed to meet
                  the performance rating that is required. But the
                  bare minimum requirements are -
   - 1.4 GHz Single Core Processor (x64 Architecture)
   - 512MB of RAM
   - 60 GB of HDD (for OS) & 10 GB of free space (for application)
   - NIC (10/100 Mbps minimum)
2. Client Side :: The client side can use any Android phone. But the
                  phone should have -
   - At least 5.0 Megapixels Camera
   - Camera Flash
   - 1GB of RAM
   - 1.2 GHz Dual Core Processor

*** Software Requirements
\begin{description}[leftmargin=6em,style=multiline]
	\item[\textbf{Server Side}] The server should have ---
	\begin{enumerate}
		\item Ubuntu Server 16.04 LTS or up.
		\item LAMP (Linux, Apache, MySQL and PHP)
		\item Mail Server
		\item UNIX DNS Manager (optional, for larger libraries)
		\item Git (for automated updates)
		\item OpenSSH (for remote administration)
	\end{enumerate}
	\item[\textbf{Client Side}] The client side should have Android 6.0 + (vanilla or almost vanilla OS is preferred)
\end{description}

\subsection{Communication Interfaces}
\begin{description}[leftmargin=6em,style=multiline]
	\item[\textbf{Server Side}] Minimum of Gigabit networking is required on the server side to handle multiple requests and send responses at the same time.
	\item[\textbf{Client Side}] GSM HSPA+, Wi-Fi(bg/n/ac) or LTE is required. Minimum speed of 4 Mbps. 
\end{description}

\section{Functional Requirements}
\subsection{User Class 1 - The Borrower}
\begin{description}[leftmargin=6em,style=multiline]
	\item[\textbf{Request}]
	\begin{enumerate}
		\item Registration
		\item Login
		\item View book details
		\item View book availability
		\item View borrowed book details / fine details
	\end{enumerate}
	\item[\textbf{Response}]
	\begin{enumerate}
		\item Registration success or failure
		\item Login success or failure.
		\item Book details
		\item Book availability
		\item Borrowed book details / fine(if any)
	\end{enumerate}
\end{description}
\subsection{User Class 2 - The Librarian}
\begin{description}[leftmargin=6em,style=multiline]
	\item[\textbf{Request}]
	\begin{enumerate}
		\item Login
		\item View book details
		\item View book availability
		\item Rent a book to a student.
		\item Deposit a book from the student.
		\item View borrowed book details / fine details
		\item Accept fine.
	\end{enumerate}
	\item[\textbf{Response}]
	\begin{enumerate}
		\item Login success or failure.
		\item Book details
		\item Book availability
		\item Book rent success (due-date)
		\item Borrowed book details.
		\item Fine acknowledgment.
	\end{enumerate}
\end{description}

\subsection{User Class 3 - The Administrator}
The administrator is the super user of the system. The admin can do anything and modify the system in any way possible.

\begin{enumerate}
	\item Can edit details of users of any level
	\item Can add librarian
	\item Have full access to the back end of the system.
\end{enumerate}

\section{Performance Requirements}
The performance requirement should not be an issue as it is a scalable system with the back end in the cloud.

It is recommended to have a VPS server for the application to work smoothly, however, shared servers can also work but with occasional hiccups.

For a small to medium sized library, DigitalOcean servers are considerable but larger libraries with bigger administrations require Amazon EC2 instances or Google Cloud Platform with Linux Server OS\footnote{The application can run on Windows based servers, but is not optimized for it.}. 

The validation and all the checks for the constraints happen on the server side and it's better to do so for preventing security exploits to the system at the cost of a few milliseconds of loss in response time.

\section{Design Constraints}
There are a few points to consider when designing and developing the system.
\begin{description}[leftmargin=6em,style=multiline]
	\item[Database] The database should be normalized all the time. Maximum permissible redundancy should not be more than 10\% at any instance.
	\item[Backups] Backups should be designed in such a way that it should be easy enough to replace the corrupted back end with a most recently backed up on withing 15 mins without any failure.
	\item[User Interface] The Android user interface should follow the material design guidelines. Similarly the iOS\footnote{Future scope} should be done to match Apple's current design guidelines. The web interface\footnotemark[2] should follow the material guideline provided by Google too.
\end{description}

\section{Software System Attributes}
\begin{description}[leftmargin=4cm,style=multiline,align=parright, font=\bfseries]
	\item[Availability:] Availability defines the proportion of time that the system is functional and working. It can be measured as a percentage of the total system downtime over a predefined period. Availability will be affected by system errors, infrastructure problems, malicious attacks, and system load.
	\item[Conceptual Integrity:] Conceptual integrity defines the consistency and coherence of the overall design. This includes the way that components or modules are designed, as well as factors such as coding style and variable naming.
	\item[Interoperability:] Interoperability is the ability of a system or different systems to operate successfully by communicating and exchanging information with other external systems written and run by external parties. An interoperable system makes it easier to exchange and reuse information internally as well as externally.
	\item[Maintainability:] Maintainability is the ability of the system to undergo changes with a degree of ease. These changes could impact components, services, features, and interfaces when adding or changing the functionality, fixing errors, and meeting new business requirements.
	\item[Manageability:] Manageability defines how easy it is for system administrators to manage the application, usually through sufficient and useful instrumentation exposed for use in monitoring systems and for debugging and performance tuning.
	\item[Reliability:] Reliability is the ability of a system to remain operational over time. Reliability is measured as the probability that a system will not fail to perform its intended functions over a specified time interval.
	\item[Reusability:] Reusability defines the capability for components and subsystems to be suitable for use in other applications and in other scenarios. Reusability minimizes the duplication of components and also the implementation time.
	\item[Scalability:] Scalability is ability of a system to either handle increases in load without impact on the performance of the system, or the ability to be readily enlarged.
	\item[Security:] Security is the capability of a system to prevent malicious or accidental actions outside of the designed usage, and to prevent disclosure or loss of information. A secure system aims to protect assets and prevent unauthorized modification of information.
	\item[Usability:] Usability defines how well the application meets the requirements of the user and consumer by being intuitive, easy to localize and globalize, providing good access for disabled users, and resulting in a good overall user experience.
\end{description}
